<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Archive — Drawing Mirror</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>

<nav class="nav">
  <span class="nav-brand">Drawing Mirror</span>
  <span id="nav-user" class="text-sm text-muted"></span>
</nav>

<!-- ── Loading ─────────────────────────────────────────────────────────── -->
<div class="container" id="wrap-loading" style="padding-top:40px;display:none;">
  <p class="loading">Loading...</p>
</div>

<!-- ── No analysis yet ────────────────────────────────────────────────── -->
<div class="container" id="wrap-none" style="padding-top:40px;display:none;">
  <h1>Your Drawing Archive</h1>
  <p class="mt-8" id="drawing-count-text"></p>
  <div class="card mt-24" style="max-width:540px;">
    <h3>Discover Your Lenses</h3>
    <p class="mt-8">Drawing Mirror will analyze your archive and surface 3–5 meaningful patterns specific to your body of work — angles that emerge from <em>your</em> drawings.</p>
    <button class="btn btn-lens mt-16" onclick="startAnalysis()">✦ Discover Lenses</button>
  </div>
</div>

<!-- ── Analysis running ───────────────────────────────────────────────── -->
<div class="container" id="wrap-running" style="padding-top:40px;display:none;">
  <h1>Analyzing Your Archive</h1>
  <p id="phase-text" class="mt-8 text-muted">Preparing...</p>
  <div class="mt-24" style="max-width:480px;">
    <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
      <span class="text-sm text-muted" id="progress-label">0 / 0 drawings</span>
      <span class="text-sm text-muted" id="progress-pct">0%</span>
    </div>
    <div class="progress-wrap"><div class="progress-bar" id="progress-bar" style="width:0%"></div></div>
  </div>
</div>

<!-- ── Failed ─────────────────────────────────────────────────────────── -->
<div class="container" id="wrap-failed" style="padding-top:40px;display:none;">
  <h1>Analysis Failed</h1>
  <p id="error-text" class="mt-8" style="color:red;"></p>
  <button class="btn btn-ghost mt-16" onclick="startAnalysis()">Try Again</button>
</div>

<!-- ── Embedding progress ─────────────────────────────────────────────── -->
<div class="container" id="wrap-embedding" style="padding-top:40px;display:none;">
  <h1>Building Visual Map</h1>
  <p class="mt-8 text-muted">Computing image embeddings for the visualization…</p>
  <div class="mt-24" style="max-width:480px;">
    <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
      <span class="text-sm text-muted" id="emb-label">0 / 0</span>
      <span class="text-sm text-muted" id="emb-pct">0%</span>
    </div>
    <div class="progress-wrap"><div class="progress-bar" id="emb-bar" style="width:0%"></div></div>
  </div>
</div>

<!-- ── Dual-pane map view ─────────────────────────────────────────────── -->
<div id="wrap-map" class="map-layout" style="display:none;">

  <!-- Left 50%: timeline / lens list -->
  <div class="map-left">

    <!-- PANEL A: Lens list -->
    <div id="panel-lenses" class="panel-full">
      <div class="panel-header">
        <span class="panel-label">Lenses</span>
        <button class="btn btn-ghost text-sm" onclick="resetAnalysis()" style="padding:4px 8px;font-size:12px;">↺ Re-analyze</button>
      </div>
      <div class="panel-scroll">
        <div id="lens-list"></div>
      </div>
    </div>

    <!-- PANEL B: Timeline -->
    <div id="panel-timeline" class="panel-full" style="display:none;">
      <div class="panel-header" style="flex-direction:column;align-items:flex-start;gap:5px;">
        <button class="btn btn-ghost text-sm" onclick="backToLenses()" style="padding:4px 10px;font-size:13px;">← Lenses</button>
        <div id="timeline-lens-name" class="timeline-title"></div>
        <div id="timeline-lens-desc" class="timeline-desc"></div>
      </div>
      <!-- Only this div scrolls -->
      <div class="panel-scroll" id="timeline-scroll">
        <div id="timeline-list"></div>
      </div>
    </div>

  </div>

  <!-- Right 50%: UMAP canvas — position:absolute, never moves -->
  <div class="map-right">
    <canvas id="umap-canvas"></canvas>
    <div id="umap-tooltip" class="umap-tooltip" style="display:none;"></div>
    <div id="map-loading" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:var(--bg);font-size:14px;color:var(--text-tertiary);">
      Loading map…
    </div>
  </div>

</div>

<script src="/static/app.js"></script>
<script>
/* ═══════════════════════════════════════════════════════════════════════
   Global state
═══════════════════════════════════════════════════════════════════════ */
let pollingInterval    = null;
let embPollingInterval = null;

let allPoints         = [];   // [{drawing_id, x, y, filename, title, drawn_date, thumbnail_url}]
let lensData          = [];
let lensRelevantMap   = {};   // { lens_id: Set<drawing_id> }
let lensDrawingsCache = {};   // { lens_id: [{id, title, drawn_date, annotation, thumbnail_url, ...}] }
let thumbImages       = {};   // { drawing_id: HTMLImageElement }
let userReactions     = {};   // { drawing_id: {reaction_type, id} } — for active lens

let mapMode       = 'lenses';
let activeLensId  = null;
let hoveredLensId = null;
let activeDrawingId  = null;  // the scroll-center drawing in timeline mode (scroll only, no hover)

let canvas, ctx;
let pointRects = [];

const THUMB_HALF = 14;
const FOCUS_HALF = 22;
const CANVAS_PAD = 32;

let scrollObserver = null;

/* ═══════════════════════════════════════════════════════════════════════
   Init / pipeline
═══════════════════════════════════════════════════════════════════════ */
async function init() {
  if (!State.userId) { window.location.href = '/'; return; }
  document.getElementById('nav-user').textContent = State.username;
  showState('loading');
  const status = await API.get(`/archive/status?user_id=${State.userId}`);
  await handleArchiveStatus(status);
}

async function handleArchiveStatus(status) {
  if (status.status === 'not_started' || (status.status === 'failed' && !status.has_lenses)) {
    try {
      const d = await API.get(`/drawings?user_id=${State.userId}`);
      document.getElementById('drawing-count-text').textContent =
        `${d.length} drawing${d.length !== 1 ? 's' : ''} ready for analysis`;
    } catch(e) {}
    if (status.status === 'failed') {
      document.getElementById('error-text').textContent = status.error_message || 'Unknown error';
      showState('failed');
    } else { showState('none'); }
  } else if (status.status === 'running' || status.status === 'pending') {
    showState('running'); updateProgress(status); startPolling();
  } else if (status.status === 'complete' || status.has_lenses) {
    await loadLensesAndStartEmbedding();
  } else if (status.status === 'failed') {
    document.getElementById('error-text').textContent = status.error_message || 'Unknown error';
    showState('failed');
  }
}

function updateProgress(status) {
  const phase = status.phase || 'preparing';
  const labels = { batch_analysis: 'Analyzing drawings…', lens_discovery: 'Discovering lenses…', done: 'Finishing up…' };
  document.getElementById('phase-text').textContent = labels[phase] || 'Processing…';
  const total = status.total_drawings || 1, done = status.analyzed_count || 0;
  const pct = phase === 'lens_discovery' ? 95 : Math.round((done / total) * 90);
  document.getElementById('progress-label').textContent = `${done} / ${total} drawings`;
  document.getElementById('progress-pct').textContent = `${pct}%`;
  document.getElementById('progress-bar').style.width = pct + '%';
}

function startPolling() {
  if (pollingInterval) return;
  pollingInterval = setInterval(async () => {
    try {
      const status = await API.get(`/archive/status?user_id=${State.userId}`);
      if (status.status === 'running' || status.status === 'pending') { updateProgress(status); }
      else { clearInterval(pollingInterval); pollingInterval = null; await handleArchiveStatus(status); }
    } catch(e) { console.error(e); }
  }, 2500);
}

async function startAnalysis() {
  showState('running');
  document.getElementById('phase-text').textContent = 'Starting analysis…';
  try { await API.post(`/archive/analyze?user_id=${State.userId}`, {}); startPolling(); }
  catch(e) { document.getElementById('error-text').textContent = e.message; showState('failed'); }
}

async function resetAnalysis() {
  if (!confirm('Delete all lenses and re-analyze? This cannot be undone.')) return;
  await startAnalysis();
}

/* ═══════════════════════════════════════════════════════════════════════
   Load lenses + start embeddings
═══════════════════════════════════════════════════════════════════════ */
async function loadLensesAndStartEmbedding() {
  const lenses = await API.get(`/lenses?user_id=${State.userId}`);
  if (!lenses.length) { showState('none'); return; }

  lensData = lenses;
  lensRelevantMap   = {};
  lensDrawingsCache = {};

  for (const lens of lenses) {
    try {
      const ld = await API.get(`/lenses/${lens.id}/drawings?user_id=${State.userId}`);
      lensDrawingsCache[lens.id] = ld.drawings;             // full objects with annotation
      lensRelevantMap[lens.id]   = new Set(ld.drawings.map(d => d.id));
      lens.drawingIds = lensRelevantMap[lens.id];
    } catch(e) {
      lensDrawingsCache[lens.id] = [];
      lensRelevantMap[lens.id]   = new Set();
      lens.drawingIds = new Set();
    }
  }

  renderLensList();

  try { await API.post(`/embeddings/generate?user_id=${State.userId}`, {}); } catch(e) {}

  const embStatus = await API.get(`/embeddings/status?user_id=${State.userId}`);
  if (embStatus.status === 'complete') { await showMap(); }
  else {
    showState('embedding');
    updateEmbProgress(embStatus);
    startEmbPolling();
  }
}

function updateEmbProgress(s) {
  const total = s.total || 1, done = s.computed || 0;
  const pct = Math.round((done / total) * 100);
  document.getElementById('emb-label').textContent = `${done} / ${total}`;
  document.getElementById('emb-pct').textContent   = `${pct}%`;
  document.getElementById('emb-bar').style.width   = pct + '%';
}

function startEmbPolling() {
  if (embPollingInterval) return;
  embPollingInterval = setInterval(async () => {
    try {
      const s = await API.get(`/embeddings/status?user_id=${State.userId}`);
      updateEmbProgress(s);
      if (s.status === 'complete') { clearInterval(embPollingInterval); embPollingInterval = null; await showMap(); }
      else if (s.status === 'error') { clearInterval(embPollingInterval); embPollingInterval = null; showState('failed'); }
    } catch(e) { console.error(e); }
  }, 2000);
}

/* ═══════════════════════════════════════════════════════════════════════
   Canvas / UMAP
═══════════════════════════════════════════════════════════════════════ */
async function showMap() {
  showState('map');
  canvas = document.getElementById('umap-canvas');
  ctx    = canvas.getContext('2d');

  try {
    const data = await API.get(`/embeddings/umap?user_id=${State.userId}`);
    allPoints = data.points;
  } catch(e) {
    document.getElementById('map-loading').textContent = 'Failed to load map.';
    return;
  }

  await preloadThumbs();
  await new Promise(r => requestAnimationFrame(r));

  resizeCanvas(); drawCanvas();
  document.getElementById('map-loading').style.display = 'none';

  canvas.addEventListener('mousemove', onCanvasMouseMove);
  canvas.addEventListener('mouseleave', onCanvasMouseLeave);
  canvas.addEventListener('click', onCanvasClick);
  window.addEventListener('resize', () => { resizeCanvas(); drawCanvas(); });
}

function preloadThumbs() {
  return new Promise(resolve => {
    let pending = allPoints.length;
    if (!pending) { resolve(); return; }
    allPoints.forEach(pt => {
      if (!pt.thumbnail_url) { pending--; if (!pending) resolve(); return; }
      const img = new Image(); img.crossOrigin = 'anonymous';
      img.onload  = () => { thumbImages[pt.drawing_id] = img; pending--; if (!pending) resolve(); };
      img.onerror = () => { pending--; if (!pending) resolve(); };
      img.src = pt.thumbnail_url;
    });
  });
}

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const parent = canvas.parentElement;
  const w = parent.offsetWidth, h = parent.offsetHeight;
  canvas.width  = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  computePointLayout(w, h);
}

function computePointLayout(w, h) {
  pointRects = allPoints.map(pt => ({
    drawing_id: pt.drawing_id,
    cx: CANVAS_PAD + pt.x * (w - CANVAS_PAD * 2),
    cy: CANVAS_PAD + pt.y * (h - CANVAS_PAD * 2),
  }));
}

function drawCanvas() {
  if (!ctx) return;
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.width / dpr, h = canvas.height / dpr;
  ctx.clearRect(0, 0, w, h);

  // In timeline mode, highlight the scroll-center drawing only (no hover interaction)
  // In lens mode, highlight drawings of the hovered lens
  let highlightSet = null, focusId = null;
  if (mapMode === 'lenses' && hoveredLensId != null) {
    highlightSet = lensRelevantMap[hoveredLensId] || new Set();
  } else if (mapMode === 'timeline') {
    if (activeDrawingId != null) {
      highlightSet = new Set([activeDrawingId]);
      focusId = activeDrawingId;
    }
  }

  const buckets = { dim: [], normal: [], highlight: [], focus: [] };
  allPoints.forEach((pt, i) => {
    const id = pt.drawing_id;
    if      (highlightSet === null)  buckets.normal.push(i);
    else if (focusId === id)         buckets.focus.push(i);
    else if (highlightSet.has(id))   buckets.highlight.push(i);
    else                             buckets.dim.push(i);
  });

  drawPoints(buckets.dim,       0.08, THUMB_HALF, null);
  drawPoints(buckets.normal,    1.0,  THUMB_HALF, null);
  drawPoints(buckets.highlight, 1.0,  THUMB_HALF, '#5856d6');
  drawPoints(buckets.focus,     1.0,  FOCUS_HALF, '#5856d6');
}

function drawPoints(indices, alpha, half, strokeColor) {
  indices.forEach(i => {
    const pt = allPoints[i], pr = pointRects[i], img = thumbImages[pt.drawing_id];
    const { cx, cy } = pr;
    ctx.save();
    ctx.globalAlpha = alpha;
    if (img) {
      const size = half * 2;
      ctx.beginPath(); ctx.roundRect(cx - half, cy - half, size, size, 3); ctx.clip();
      const iw = img.naturalWidth || img.width, ih = img.naturalHeight || img.height;
      const scale = Math.max(size / iw, size / ih);
      const sw = size / scale, sh = size / scale;
      ctx.drawImage(img, (iw - sw) / 2, (ih - sh) / 2, sw, sh, cx - half, cy - half, size, size);
    } else {
      ctx.fillStyle = '#c7c7ef';
      ctx.beginPath(); ctx.arc(cx, cy, half * 0.6, 0, Math.PI * 2); ctx.fill();
    }
    if (strokeColor) {
      ctx.restore(); ctx.save(); ctx.globalAlpha = alpha;
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = half === FOCUS_HALF ? 3 : 2;
      ctx.beginPath(); ctx.roundRect(cx - half, cy - half, half * 2, half * 2, 3); ctx.stroke();
    }
    ctx.restore();
  });
}

function hitTest(mx, my) {
  for (let i = pointRects.length - 1; i >= 0; i--) {
    const { cx, cy, drawing_id } = pointRects[i];
    const half = drawing_id === activeDrawingId ? FOCUS_HALF : THUMB_HALF;
    if (Math.abs(mx - cx) <= half && Math.abs(my - cy) <= half) return drawing_id;
  }
  return null;
}

function getCanvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  return { mx: e.clientX - rect.left, my: e.clientY - rect.top };
}

function onCanvasMouseMove(e) {
  const { mx, my } = getCanvasCoords(e);
  const hit = hitTest(mx, my);
  // In timeline mode canvas hover shows tooltip but does NOT change canvas highlights
  // (highlights are driven by scroll position only)
  const tip = document.getElementById('umap-tooltip');
  if (hit) {
    const pt = allPoints.find(p => p.drawing_id === hit);
    tip.innerHTML = `<strong>${pt.title || pt.filename}</strong><br><span style="color:var(--text-tertiary)">${pt.drawn_date || ''}</span>`;
    tip.style.display = 'block'; tip.style.left = (mx + 12) + 'px'; tip.style.top = (my - 10) + 'px';
    canvas.style.cursor = 'pointer';
  } else {
    tip.style.display = 'none'; canvas.style.cursor = '';
  }
}

function onCanvasMouseLeave() {
  document.getElementById('umap-tooltip').style.display = 'none';
  canvas.style.cursor = '';
}

function onCanvasClick(e) {
  const hit = hitTest(...Object.values(getCanvasCoords(e)));
  if (hit) window.location.href = `/drawing-detail?drawing_id=${hit}&user_id=${State.userId}`;
}

/* ═══════════════════════════════════════════════════════════════════════
   Lens list panel
═══════════════════════════════════════════════════════════════════════ */
function renderLensList() {
  const list = document.getElementById('lens-list');
  list.innerHTML = '';
  lensData.forEach(lens => {
    const div = document.createElement('div');
    div.className = 'lens-list-item';
    div.innerHTML = `<div class="lens-name">${lens.name}</div><div class="lens-count">${lens.relevant_count || 0} drawings</div>`;
    div.addEventListener('mouseenter', () => { if (mapMode === 'lenses') { hoveredLensId = lens.id; drawCanvas(); } });
    div.addEventListener('mouseleave', () => { if (mapMode === 'lenses') { hoveredLensId = null; drawCanvas(); } });
    div.addEventListener('click', () => onLensClick(lens.id));
    list.appendChild(div);
  });
}

function onLensClick(lensId) {
  mapMode = 'timeline'; activeLensId = lensId; hoveredLensId = null; activeDrawingId = null;

  const lens = lensData.find(l => l.id === lensId);
  document.getElementById('timeline-lens-name').textContent = lens.name;
  document.getElementById('timeline-lens-desc').textContent = lens.description;

  renderTimeline(lensId);
  document.getElementById('panel-lenses').style.display   = 'none';
  document.getElementById('panel-timeline').style.display = '';
  drawCanvas();
}

function backToLenses() {
  mapMode = 'lenses'; activeLensId = null; activeDrawingId = null;
  if (scrollObserver) { scrollObserver.disconnect(); scrollObserver = null; }
  document.getElementById('panel-timeline').style.display = 'none';
  document.getElementById('panel-lenses').style.display   = '';
  drawCanvas();
}

/* ═══════════════════════════════════════════════════════════════════════
   Timeline panel
═══════════════════════════════════════════════════════════════════════ */
function renderTimeline(lensId) {
  const drawings = lensDrawingsCache[lensId] || [];
  // Sort chronologically (already sorted from API, but just in case)
  const sorted = [...drawings].sort((a, b) => (a.drawn_date || '').localeCompare(b.drawn_date || ''));

  const list = document.getElementById('timeline-list');
  list.innerHTML = '';

  if (!sorted.length) {
    list.innerHTML = '<p class="text-sm text-muted" style="padding:8px 0;">No drawings above relevance threshold.</p>';
    return;
  }

  let lastYear = null;
  sorted.forEach(drawing => {
    const year = drawing.drawn_date ? drawing.drawn_date.slice(0, 4) : null;
    if (year && year !== lastYear) {
      lastYear = year;
      const yl = document.createElement('div');
      yl.className = 'timeline-year-label';
      yl.textContent = year;
      list.appendChild(yl);
    }

    const thumb = thumbImages[drawing.id];
    const thumbSrc  = thumb ? thumb.src : (drawing.thumbnail_url || '');
    const fullSrc   = `/api/drawings/${drawing.id}/image`;

    const row = document.createElement('div');
    row.className = 'timeline-row';
    row.dataset.drawingId = drawing.id;

    // Compact view (shown by default, when not tl-active)
    row.innerHTML = `
      <div class="tl-compact">
        <div class="tl-thumb-wrap">
          ${thumbSrc ? `<img class="tl-thumb" src="${thumbSrc}" alt="">` : `<div class="tl-thumb tl-thumb-placeholder"></div>`}
        </div>
        <div class="tl-meta">
          <div class="tl-title">${drawing.title || drawing.filename}</div>
          <div class="tl-date">${drawing.drawn_date || ''}</div>
        </div>
      </div>

      <div class="tl-card">
        <div class="tl-card-img-wrap">
          <img class="tl-card-img" src="${fullSrc}" alt="${drawing.title || drawing.filename}">
        </div>
        <div class="tl-card-body">
          <div class="tl-card-title">${drawing.title || drawing.filename}</div>
          <div class="tl-card-date">${drawing.drawn_date || ''}</div>
          <div class="tl-card-annotation">${drawing.annotation || '<span style="color:var(--text-tertiary);font-style:italic;">Annotation loading…</span>'}</div>
          <div class="tl-card-reactions" id="reactions-${drawing.id}"></div>
        </div>
      </div>
    `;

    // No hover ↔ canvas linkage in timeline mode — scroll position drives everything
    list.appendChild(row);
  });

  // Spacer: tall enough so the last real row can scroll to the center detection zone
  const spacer = document.createElement('div');
  spacer.className = 'tl-bottom-spacer';
  list.appendChild(spacer);

  // Prediction card (loads asynchronously)
  const predCard = document.createElement('div');
  predCard.className = 'tl-prediction-card';
  predCard.id = 'tl-prediction-card';
  predCard.innerHTML = `
    <div class="tl-prediction-header">
      <span class="tl-prediction-icon">✦</span>
      <span class="tl-prediction-label">What might come next</span>
    </div>
    <div class="tl-prediction-body" id="tl-prediction-body">
      <div class="tl-prediction-placeholder">
        <div class="tl-prediction-shimmer"></div>
        <div class="tl-prediction-shimmer" style="width:80%;"></div>
        <div class="tl-prediction-shimmer" style="width:65%;"></div>
      </div>
    </div>
  `;
  list.appendChild(predCard);

  // Load existing reactions for this lens's drawings
  loadReactions(sorted.map(d => d.id));
  setupScrollObserver(lensId);
  loadPrediction(lensId);
}

/* ═══════════════════════════════════════════════════════════════════════
   IntersectionObserver — one active card at a time
═══════════════════════════════════════════════════════════════════════ */
function setupScrollObserver(lensId) {
  if (scrollObserver) scrollObserver.disconnect();

  const scrollEl = document.getElementById('timeline-scroll');
  if (!scrollEl) return;

  let currentActive = null;

  scrollObserver = new IntersectionObserver(entries => {
    // Sort by intersection ratio descending so the most-visible row wins
    const intersecting = entries
      .filter(e => e.isIntersecting && e.target.classList.contains('timeline-row'))
      .sort((a, b) => b.intersectionRatio - a.intersectionRatio);

    if (intersecting.length > 0) {
      const entry = intersecting[0];
      const drawingId = parseInt(entry.target.dataset.drawingId);

      if (currentActive && currentActive !== entry.target) {
        currentActive.classList.remove('tl-active');
      }
      entry.target.classList.add('tl-active');
      currentActive = entry.target;
      activeDrawingId = drawingId;
      drawCanvas();
    } else {
      // Check if any non-intersecting entry was the current active
      entries.forEach(entry => {
        if (!entry.isIntersecting && currentActive === entry.target) {
          entry.target.classList.remove('tl-active');
          currentActive = null;
          activeDrawingId = null;
          drawCanvas();
        }
      });
    }
  }, {
    root: scrollEl,
    // Asymmetric margin: top edge cuts off 30%, bottom only 20%
    // This lets items near the bottom of the list activate before the spacer is visible
    rootMargin: '-30% 0px -20% 0px',
    threshold: [0.1, 0.5],
  });

  scrollEl.querySelectorAll('.timeline-row').forEach(row => scrollObserver.observe(row));
}

/* ═══════════════════════════════════════════════════════════════════════
   Prediction card
═══════════════════════════════════════════════════════════════════════ */
const predictionCache = {};  // { lens_id: text }

async function loadPrediction(lensId) {
  const bodyEl = document.getElementById('tl-prediction-body');
  if (!bodyEl) return;

  // Use cache if available
  if (predictionCache[lensId]) {
    renderPrediction(predictionCache[lensId]);
    return;
  }

  try {
    const data = await API.get(`/lenses/${lensId}/prediction?user_id=${State.userId}`);
    predictionCache[lensId] = data.prediction;
    renderPrediction(data.prediction);
  } catch(e) {
    // Annotations might not be ready yet — show a soft message instead of an error
    if (bodyEl) {
      bodyEl.innerHTML = `<p class="tl-prediction-text" style="color:var(--text-tertiary);font-style:normal;">Prediction will appear once annotations are ready.</p>`;
    }
  }
}

function renderPrediction(text) {
  const bodyEl = document.getElementById('tl-prediction-body');
  if (!bodyEl) return;
  bodyEl.innerHTML = `<p class="tl-prediction-text">${text}</p>`;
  // Fade the card in
  const card = document.getElementById('tl-prediction-card');
  if (card) card.classList.add('tl-prediction-ready');
}

/* ═══════════════════════════════════════════════════════════════════════
   Reactions
═══════════════════════════════════════════════════════════════════════ */
async function loadReactions(drawingIds) {
  for (const did of drawingIds) {
    try {
      const reactions = await API.get(`/reactions?drawing_id=${did}&user_id=${State.userId}`);
      const lensAnnotation = reactions.find(r => r.target_type === 'lens_annotation' && r.target_id == String(activeLensId));
      const drawingAnalysis = reactions.find(r => r.target_type === 'drawing_analysis');
      userReactions[did] = { lens: lensAnnotation, analysis: drawingAnalysis };
      renderReactionButtons(did);
    } catch(e) {}
  }
}

function renderReactionButtons(drawingId) {
  const el = document.getElementById(`reactions-${drawingId}`);
  if (!el) return;

  const existing = (userReactions[drawingId] || {}).lens;
  const reactionType = existing ? existing.reaction_type : null;

  const agreeClass    = reactionType === 'agree'    ? 'tl-rxn-btn active-agree'    : 'tl-rxn-btn';
  const disagreeClass = reactionType === 'disagree' ? 'tl-rxn-btn active-disagree' : 'tl-rxn-btn';

  el.innerHTML = `
    <button class="${agreeClass}"    data-did="${drawingId}" data-type="agree"    onclick="handleReaction(${drawingId},'agree')">✓ Agree</button>
    <button class="${disagreeClass}" data-did="${drawingId}" data-type="disagree" onclick="handleReaction(${drawingId},'disagree')">✗ Disagree</button>
    <a class="tl-rxn-link" href="/drawing-detail?drawing_id=${drawingId}&user_id=${State.userId}&lens_id=${activeLensId}">View detail →</a>
  `;
}

async function handleReaction(drawingId, reactionType) {
  try {
    await API.post('/reactions', {
      user_id:       State.userId,
      drawing_id:    drawingId,
      target_type:   'lens_annotation',
      target_id:     String(activeLensId),
      reaction_type: reactionType,
    });
    // Refresh this drawing's reactions
    const reactions = await API.get(`/reactions?drawing_id=${drawingId}&user_id=${State.userId}`);
    const lensAnnotation = reactions.find(r => r.target_type === 'lens_annotation' && r.target_id == String(activeLensId));
    userReactions[drawingId] = { ...userReactions[drawingId], lens: lensAnnotation };
    renderReactionButtons(drawingId);
  } catch(e) { console.error('Reaction failed:', e); }
}

/* ═══════════════════════════════════════════════════════════════════════
   showState
═══════════════════════════════════════════════════════════════════════ */
function showState(name) {
  ['loading','none','running','failed','embedding','map'].forEach(s => {
    const el = document.getElementById(s === 'map' ? 'wrap-map' : 'wrap-' + s);
    if (!el) return;
    el.style.display = s === name ? (s === 'map' ? 'flex' : '') : 'none';
  });
}

init();
</script>
</body>
</html>
